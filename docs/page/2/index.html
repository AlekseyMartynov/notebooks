<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width">
    <meta name="theme-color" content="#000000">
    <title>AM’s Notebooks ― страница 2 из 2</title>
    <link rel="canonical" href="https://alekseymartynov.github.io/notebooks/page/2/">
    <link rel="alternate" type="application/rss+xml" href="https://alekseymartynov.github.io/notebooks/rss.xml">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,300,600&subset=latin,greek,cyrillic,latin-ext">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <link rel="stylesheet" href="/notebooks/style.css">
    <meta name="robots" content="noarchive, nosnippet">
    <script>
        /p=\d/.test(location.search) && document.write("<script src=/notebooks/legacy-id-redirect.js><\/script>");
    </script>
    <!-- Trackers place -->
</head>
<body>
    <div id="page">
        <div id="header">
            <div id="headerimage">
                <h1><a href="/notebooks/">AM’s Notebooks</a></h1>
                <div class="description">Misc tech notes</div>
            </div>
        </div>
        <hr class="plainscape">
        <div id="wrapper" class="hasfloats">
            <div id="content">
                
    <div class="post">
        <h2><a href="/notebooks/теорема-котельникова-дискретизация/" rel="bookmark">Подробнее про теорему Котельникова и дискретизацию сигналов</a></h2>
        <div class="postmetadata">01.12.2012</div>
        <div class="entry">
            <p>Теорему Котельникова я уже вскользь упоминал в статьях про <del class="removed_link">интерполяцию</del> и <del class="removed_link">синтез гитарного звука</del>. Сегодня чувствую в себе силы углубиться в тему по-полной, буквально нырнуть с головой.</p>
<p>Чтобы никого не обидеть, теорему эту называют теоремой Котельникова — Найквиста — Уиттакера — Шеннона, или попросту теоремой отсчётов (the Sampling theorem). Она считается одним из важнейших результатов теории информации.</p>
<p>Формулировка достаточно простая:</p>
<blockquote>
<p>Если аналоговый сигнал не содержит в своем спектре частот выше <code>Fmax</code>, то его можно идеально точно восстановить по дискретным отсчётам, взятым равномерно с частотой строго большей <code>2·Fmax</code>.</p>
</blockquote>
<p>Даже если вы не имеете никакого отношения к обработке сигналов, очень может быть, что вам знакома фраза “CD quality 44100 Hz”. Имеется в виду, что на компакт-дисках звук хранится в виде дискретных отсчётов, по 44100 штук на секунду. А это, согласно озвученной теореме, означает что “на CD можно идеально записать звук с частотой до 22050 Гц”, что вполне себе хорошо, так как слышимый человеком диапазон укладывается в эти рамки.</p>
<p>Казалось бы, всё отлично, что тут ещё обсуждать. Но у меня возник ряд вопросов:</p>
<ol>
<li><p>Ограниченность по частоте — так ли это просто, как кажется на первый взгляд?</p>
</li>
<li><p>Как именно предполагается восстанавливать сигнал, чтобы получилось “идеально точно”?</p>
</li>
<li><p>Что будет, если в оцифровываемом сигнале окажутся частоты равные или превосходящие допустимую половину частоты дискретизации? Они проигнорируются, или произойдет что-то другое?</p>
</li>
</ol>
<p>В процессе поиска ответов я углублялся в детали, а оттуда сверкал глазами скрывающийся в них дьявол.</p>
<p>Должен предупредить, будет много страшной математики…</p>

            <p><a href="/notebooks/теорема-котельникова-дискретизация/#more" class="more-link">Читать далее &#9656;</a></p>
        </div>
    </div>
    <div class="post">
        <h2><a href="/notebooks/linux-server-backup-to-webdav/" rel="bookmark">Backup сервера прямо в Яндекс.Диск</a></h2>
        <div class="postmetadata">01.08.2012</div>
        <div class="entry">
            <p>В предыдущих двух статьях я <del class="removed_link">настраивал LAMP на VPS</del> и <del class="removed_link">прикручивал к нему nginx</del>. Следующее, о чем сразу начинаешь думать — как бы все это не потерять. То есть речь заходит о резервном копировании.</p>
<p>Обсудим по порядку: что, куда и как бэкапить.</p>

            <p><a href="/notebooks/linux-server-backup-to-webdav/#more" class="more-link">Читать далее &#9656;</a></p>
        </div>
    </div>
    <div class="post">
        <h2><a href="/notebooks/php-sqlite-case-insensitive-like-utf8/" rel="bookmark">PHP SQLite case-insensitive LIKE for Unicode strings</a></h2>
        <div class="postmetadata">05.04.2011</div>
        <div class="entry">
            <p>Official SQLite <a href="https://www.sqlite.org/lang_expr.html#like" target="_blank">docs</a> state:</p>
<blockquote>
<p>SQLite only understands upper/lower case for ASCII characters by default. The LIKE operator is case sensitive by default for unicode characters that are beyond the ASCII range.</p>
</blockquote>
<p>It’s the major inconvenience in using SQLite. Googling for a solution gives links to a lot of discussions, especially about enabling a certain <a href="https://www.sqlite.org/src/doc/trunk/ext/icu/README.txt" target="_blank">ICU extension</a>.</p>
<p>I am here to give you a complete answer to the question <strong>How to make the LIKE operator case-insensitive for UTF-8 strings when using SQLite via PHP PDO</strong>:</p>
<pre><code class="language-php">$pdo = new PDO(&quot;sqlite::memory:&quot;);

# BEGIN

function lexa_ci_utf8_like($mask, $value) {
    $mask = str_replace(
        array(&quot;%&quot;, &quot;_&quot;),
        array(&quot;.*?&quot;, &quot;.&quot;),
        preg_quote($mask, &quot;/&quot;)
    );
    $mask = &quot;/^$mask$/ui&quot;;
    return preg_match($mask, $value);
}

$pdo-&gt;sqliteCreateFunction('like', &quot;lexa_ci_utf8_like&quot;, 2);

# END

$pdo-&gt;exec(&quot;create table t1 (x)&quot;);
$pdo-&gt;exec(&quot;insert into t1 (x) values ('[Привет España Dvořák]')&quot;);

header(&quot;Content-Type: text/plain; charset=utf8&quot;);
$q = $pdo-&gt;query(&quot;select x from t1 where x like '[_РИ%Ñ%ŘÁ_]'&quot;);
print $q-&gt;fetchColumn();
</code></pre>
<p>The main idea is to override the default implementation of the LIKE function by using the <code>PDO::sqliteCreateFunction</code> call. It’s what the official FAQ <a href="https://www.sqlite.org/faq.html#q18" target="_blank">suggests</a>.</p>
<p>Advantages:</p>
<ul>
<li>it works</li>
<li>no need to recompile anything</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>it’s obviously slower than the native implementation</li>
<li>The <code>PDO::sqliteCreateFunction</code> method is currently <a href="https://php.net/manual/en/pdo.sqlitecreatefunction.php" target="_blank">marked experimental</a></li>
</ul>
<p>Anyway, I hope this post will help you.</p>

        </div>
    </div>

<div class="prevnext hasfloats">
    <div class="next">
        <a rel="next" href="/notebooks/">Позже &#9656;</a>
    </div>
</div>


            </div>
        </div>
        <hr class="plainscape">
        <div id="footer">
            <p>
                Материалы опубликованы на условиях лицензии
                <a rel="license" href="https://creativecommons.org/licenses/by/3.0/deed.ru" target="_blank">Creative Commons Attribution 3.0 Unported</a>.
            </p>
            <p>
                Proudly hosted by <a href="https://m.do.co/c/8183daf27a39" rel="nofollow" target="_blank">DigitalOcean</a>
            </p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/dockerfile.min.js"></script>

    <script>
        addEventListener("DOMContentLoaded", function() {
            hljs.highlightAll();
        });
    </script>

</body>
</html>
